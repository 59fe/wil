#!/usr/bin/env node
'use strict';

const GC = require('../module/setGlobalConfig')
const repoPath = require('../module/getRepoPath')()
const qiniu = require("qiniu")
const path = require("path")
const program = require('commander')
const co = require("co")
const chalk = require("chalk")
const exec = require('child-process-promise').exec
const log = require("../module/log")
const dive = require("../module/dive")
const getAkSk = require("../module/getAkSk.js")
const pushTag = require("../module/pushTag")
const checkDistProd = require("../module/checkDistProd")

const deployDir = path.resolve(GC.deployDir)
program.parse(process.argv)

let gen = function* () {
  // 发布目录
  const deployDir = path.resolve(repoPath, GC.deployDir)
  // 检测发布目录（默认dist/）里是否已经编译成生产环境代码，如果不是则提醒、退出
  const isDistProd = yield checkDistProd(deployDir)
  if (!isDistProd) {
    log.error(`请先进行${chalk.magenta('生产环境')}编译打包，再进行发布！`)
    log.error('自动化发布中止...', {exit: true})
  }
  else {log.success('发布文件校验通过')}

  const execRet = yield exec('git remote show origin -n | grep "Fetch URL:"')
  // 得到项目git仓库名
  const repoName = path.basename(execRet.stdout).replace(/.git.*\n/, '')
  const AkSk = yield getAkSk()
  qiniu.conf.ACCESS_KEY = AkSk.ak
  qiniu.conf.SECRET_KEY = AkSk.sk

  function uptoken(bucket, key) {
    let putPolicy = new qiniu.rs.PutPolicy(bucket + ":" + key);
    return putPolicy.token();
  }
  function uploadFile(uptoken, key, localFile) {
    let extra = new qiniu.io.PutExtra()
    qiniu.io.putFile(uptoken, key, localFile, extra, function(err, ret) {
      if(!err) {
        let cdnUrl = path.join(GC.cdnHost, ret.key)
        // 上传成功， 处理返回值
        log.success(chalk.cyan.underline(cdnUrl) + ' 发布成功！')
        //console.dir(ret.hash, ret.key, ret.persistentId);
      } else {
        // 上传失败， 处理返回代码
        log.error(err)
      }
    });
  }

  // 打tag
  const tagName = program.args[0].trim()
  if (tagName.length && tagName != Object.prototype.toString()) {
    log.info(`git Tag ${chalk.cyan('[' + tagName + ']')} 推送中... \n`)
    pushTag(tagName)
  }
  dive(deployDir, {
    fileAction: (fullPath) => {
      const pathAfterDeployDir = fullPath.split(deployDir + '/')[1]
      // 七牛 key
      const key = path.join('repo', repoName, pathAfterDeployDir)

      let token = uptoken(GC.bucket, key)
      //调用uploadFile上传
      uploadFile(token, key, fullPath)
    },
    allDoneAction: () => {
      log.info('可以按住[Command]键，单击(iTerm2)或双击(原生Terminal)下面的链接直接查看CDN资源')
    }
  })
  dive(deployDir, (fullPath) => {
  })
  return 'CDN发布开始...'
}

co(gen).then((val) => {
  log.info(val)
}, (err) => {
  console.error(err.stack);
})
